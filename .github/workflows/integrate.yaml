name: Integrate

on:
  pull_request:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

# permissions:
#   contents: read

env:
  NODE_ENV: development

jobs:
  audit:
    name: Audit
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
      - name: Audit
        run: bash scripts/audit.sh

  lint:
    name: Lint
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
      - name: Install Node
        uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: npm
      - name: Install Node Dependencies
        run: npm ci
      - name: Lint
        uses: trunk-io/trunk-action@v1
# # FOR WHEN DOING A FULL CHECK
# - name: Trunk Check
#   uses: trunk-io/trunk-action@v1
#   with:
#     check-mode: all

# jobs:
#   trunk_check:
#     name: Trunk Check Runner
#     runs-on: ubuntu-22.04

#     steps:
#       - name: Checkout
#         uses: actions/checkout@v3

#       - name: Use Node.js
#         uses: actions/setup-node@v3
#         with:
#           node-version: "18.x"
#           cache: "npm"
#       - name: Install dependencies
#         run: npm ci
#       - run: npm run build --if-present
#       - run: npm test

#       - name: Trunk Check
#         uses: trunk-io/trunk-action@v1

# # Cache dependencies, generated files?, and artifacts (docs, website, target files, logs / changelog, containers)
# # jobs:
# #   example-job:
#     steps:
#       - name: Cache node modules
#         uses: actions/cache@v3
#         env:
#           cache-name: cache-node-modules
#         with:
#           path: ~/.npm
#           key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}
#           restore-keys: |
#             ${{ runner.os }}-build-${{ env.cache-name }}-

# what do i do about versioning? like functions and docs which can be versioned diff. does it matter?

# when reusable workflow updates (should be semver), make sure all the workflows using it are retriggered? or not worth?

#Any environment variables set in an env context defined at the workflow level in the caller workflow are not propagated to the called workflow.
#To reuse variables in multiple workflows, set them at the organization, repository, or environment levels and reference them using the vars context.
#cache artifacts from build and artifacts from test to be used in code coverage test???

# SET IT UP SO THAT if main fails, you can't run merge any more pull requests (even currently merging).
# prob use a context variable or something.
# Prob should set it up so that you do a reg partial PR test and if u get approval then
# u should do a /trunk merge automatically which will run the entire full suite of tests on everything b4 merging
# that way whats being merged is completely freshly up to date and totally correct and has no logical pr merge conflicts either
# so then what that means is that main basically can't fail outside of a freak situation like the runners being down
# also consider building during the initial PR to have the artifacts ready for code review??? then just publish it?
# maybe not all artifacts and just "packages", idk
